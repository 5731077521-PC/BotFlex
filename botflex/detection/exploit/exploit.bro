##! This script analyzes exploit attempts that can be a precursor to botnet infection. 
##! For the time being, we look at the number of failed login attempts (break in) and
##! communication with ip's blacklisted for being involved in exploit activities. 

@load ./break-in
@load botflex/config
@load botflex/utils/types
@load botflex/services/blacklist_mgr
@load botflex/detection/exploit/break-in

module Exploit;

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		ts:                		time              &log;
		victim_ip:         		addr              &log;
		ssh_attackers:     		string            &log;
		blacklist_attacker_ip:     	string            &log;
		blacklist_attacker_url:     	string            &log;
		msg:               		string            &log;
		submsg:               		string            &log;
		
	};
	
	redef record connection += {
	conn: Info &optional;
	};
	
	## The contributory factors to major event exploit
	type exploit_tributary: enum { Breakin, Blacklist_exploit_match };

	## Expire interval for the global table concerned with maintaining exploit info
	const wnd_exploit = 10mins &redef;

	## The evaluation mode (one of the modes defined in enum evaluation_mode in utils/types)
	const exploit_evaluation_mode = OR;

	## Event that can be handled to access the exploit
	## record as it is sent on to the logging framework.
	global log_exploit: event(rec: Info);

	## The event that sufficient evidence has been gathered to declare the
	## exploit phase of botnet infection lifecycle
	global exploit: event( victim: addr, weight: double );

	global ip_blacklist_match: event( our_ip: addr, other_ip: addr, bl_source: string );
	global url_blacklist_match: event( our_ip: addr, other_ip: addr, bad_url: string, bl_source: string );

	const weight_breakin = 1.0 &redef;
	const weight_exploit_blacklist_match = 0.5 &redef;
}

## Type of the value of the global table table_exploit
## Additional contributary factors that increase the confidence
## about major event exploit should be added here. For now, we are
## going with boolean scoring. Later, this may need to be adjusted if 
## we choose to use weights.  
type ExploitRecord: record {
	tb_tributary: table[ exploit_tributary ] of bool;
	ssh_attackers: set[addr];
	blacklist_attacker: string &default="";
	blacklist_attacker_url: string &default="";
	submsg: string &default="";
	reported_ip: set[addr];
    	reported_url: set[string];     	
};


event bro_init()
	{
	Log::create_stream( Exploit::LOG, [$columns=Info, $ev=log_exploit] );
	}

event Input::update_finished(name: string, source: string) 
	{
	if ( name == "config_stream" )
		{
		if ( "wnd_exploit" in Config::table_config )
			wnd_exploit = string_to_interval(Config::table_config["wnd_exploit"]$value);
		else
			print "Can't find Exploit::wnd_exploit";

		if ( "weight_breakin" in Config::table_config )
			weight_breakin = to_double(Config::table_config["weight_breakin"]$value);
		else
			print "Can't find Exploit::weight_breakin";

		if ( "weight_exploit_blacklist_match" in Config::table_config )
			weight_exploit_blacklist_match = to_double(Config::table_config["weight_exploit_blacklist_match"]$value);
		else
			print "Can't find Exploit::weight_exploit_blacklist_match";

		if ( "evaluation_mode" in Config::table_config )
			{
			local str_mode = Config::table_config["evaluation_mode"]$value;
			exploit_evaluation_mode = string_to_evaluationmode(str_mode);
			}
		else
			print "Can't find Exploit::evaluation_mode";
		}
	}

global exploit_info:Exploit::Info;

## The following set of functions calculate and, or and majority on a table of
## booleans
function get_and( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( !tb[rec] )
			return F;
		}
	return T;
	}

function get_or( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( tb[rec] )
			return T;
		}
	return F;	
	}

function get_majority( tb : table[exploit_tributary] of bool ): bool
	{
	local t = 0;
	local f = 0;
	for ( rec in tb )
		{
		if ( tb[rec] )
			++t;
		else
			++f;
		}

	if ( f > t )
		return F;
	else
		return T;
	}

## The function that decides whether or not the major event exploit should
## be generated. It is called (i) every time an entry in the global table 
## table_exploit reaches certain age defined by the table attribute &create_expire,
## or (ii) Any of the counters for a source ip exceeds its threshold. 

function evaluate( victim_ip: addr, t: table[addr] of ExploitRecord ): bool
	{
	local do_report: bool;
	if ( exploit_evaluation_mode == OR )
		do_report = get_or(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == AND )
		do_report = get_and(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == MAJORITY )
		do_report = get_majority(t[victim_ip]$tb_tributary);
	
	if( do_report )
		{
		local msg = "";
		local weight = 0.0;

		## FIXME: In future, we might want to accumulate these different weights,
		## especially, when evaluation mode is not OR 
		if ( t[victim_ip]$tb_tributary[Breakin] )
			{
			msg = msg + fmt("%s tried to break into: %s;", 
			setaddr_to_string(t[victim_ip]$ssh_attackers,","), t[victim_ip]$submsg );
			weight = weight_breakin;	
			}
		if ( t[victim_ip]$tb_tributary[Blacklist_exploit_match] )
			{
			msg = msg + fmt("Host Exploit: %s",t[victim_ip]$submsg);
			weight = weight_exploit_blacklist_match;	
			}	

		event Exploit::exploit( victim_ip, weight );

		## Log bot_attack related entries
		exploit_info$ts = network_time();
		exploit_info$victim_ip = victim_ip;
		exploit_info$ssh_attackers = setaddr_to_string(t[victim_ip]$ssh_attackers,",");
		exploit_info$msg = msg;
		exploit_info$submsg = t[victim_ip]$submsg;
		exploit_info$blacklist_attacker_ip = t[victim_ip]$blacklist_attacker;
		exploit_info$blacklist_attacker_url = t[victim_ip]$blacklist_attacker_url;

		Log::write(Exploit::LOG,exploit_info);
		return T;
		}
	return F;
	}

## Called when an entry in the global table table_exploit exceeds certain age, as specified
## in the table attribute create_expire.
function exploit_record_expired(t: table[addr] of ExploitRecord, idx: any): interval
	{
	evaluate( idx, t );
	return Exploit::wnd_exploit;
	}


## The global state table that maintains various information pertaining to the
## major event exploit, and is analyzed when a decision has to be made whether
## or not to declare the major event exploit.
global table_exploit: table[addr] of ExploitRecord &create_expire=0secs &expire_func=exploit_record_expired;

function get_exploit_record(): ExploitRecord
	{
	local rec: ExploitRecord;
	local s1: set[addr];
	rec$ssh_attackers = s1;
	local s2: set[addr];
	rec$reported_ip = s2;
	local s3: set[string];
	rec$reported_url = s3;	
	local t: table[ exploit_tributary ] of bool &default=F;
	rec$tb_tributary = t;
	return rec;
	}

event Breakin::breakin( victim_ip: addr, ssh_attackers: set[addr], msg: string )
	{
	if ( victim_ip !in table_exploit )
		table_exploit[victim_ip] = get_exploit_record();

	# Update breakin info
	table_exploit[victim_ip]$tb_tributary[ Breakin ] = T;	
	table_exploit[victim_ip]$ssh_attackers = ssh_attackers;	
	table_exploit[victim_ip]$submsg = table_exploit[victim_ip]$submsg + msg + ";";

	local done = evaluate( victim_ip, table_exploit );
	if ( done )
		{
		delete table_exploit[victim_ip]$tb_tributary[ Breakin ];
		for ( rec in table_exploit[victim_ip]$ssh_attackers )	
			delete table_exploit[victim_ip]$ssh_attackers[rec];	
		table_exploit[victim_ip]$submsg = "";
		}	
	}




event Exploit::url_blacklist_match( our_ip: addr, other_ip: addr, bad_url: string, bl_source: string )
	{
	local msg = fmt("Exploit URL blacklist matched (source: %s);", bl_source);


	if ( our_ip !in table_exploit )
		{
		table_exploit[our_ip] = get_exploit_record();
		}

	if ( bad_url !in table_exploit[our_ip]$reported_url )
		{
		table_exploit[our_ip]$submsg = msg;
		table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
		table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
		table_exploit[our_ip]$blacklist_attacker_url = bad_url;

		local done = evaluate( our_ip, table_exploit );
		if ( done )
			{
			add table_exploit[our_ip]$reported_url[bad_url];
			delete table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ];
			table_exploit[our_ip]$blacklist_attacker = "";
			table_exploit[our_ip]$blacklist_attacker_url = "";
			}	
		}	
	}


event Exploit::ip_blacklist_match( our_ip: addr, other_ip: addr, bl_source: string )
	{
	local do_update=F;
	if ( our_ip !in table_exploit )
		table_exploit[our_ip] = get_exploit_record();

	if ( other_ip !in table_exploit[our_ip]$reported_ip )
		{
		table_exploit[our_ip]$submsg = fmt("Exploit IP matched blacklist (source: %s);",bl_source );
		table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
		table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
		do_update = T;
		}
	
	local done = F;
	if ( do_update )
		done = evaluate( our_ip, table_exploit );
	if ( done )
		{
		add table_exploit[our_ip]$reported_ip[other_ip];
		delete table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ];
		table_exploit[our_ip]$blacklist_attacker = "";
		}	
	}







